---
title: Motivation
editor:
  markdown:
    wrap: sentence
format:
  html:
    include-in-header: assets/head-content.html
---

So far, we've really only seen Shiny _Express_: a simple way to learn and create basic apps.
As we'll discuss here, the same things that make Express simple also make it difficult to manage complexity when your app grows in size and sophistication.[^streamlit-comp]
And, although we'll cover some techniques for managing complexity and adding sophistication to Express, when you find yourself reaching for these techniques, it might be time to switch to Shiny Core.
Shiny Core is a slightly more involved way to write apps using the same [components](ui-components.qmd) and [reactivity](reactive-foundations.qmd) you've already learned.
The main difference is that Shiny Core embraces concepts like [decoupling](#decoupling) and [functional programming](#functional) which enforces programming patterns that, although require more effort upfront, will make it easier to manage complexity as your app grows.

If you're already convinced that Shiny Core is right for your app, the [next article](express-difference.qmd) outlines the syntax differences and provides a guide for transitioning from Express to Core.

[^streamlit-comp]: [Streamlit](https://streamlit.io/) is similar to Express in that it's easy to get started with, but difficult to manage complexity. See [this article](https://www.shinyapps.io/articles/streamlit-vs-shiny/) for a comparison between Streamlit and Shiny.

## Decoupling {#decoupling}

A big reason for Express' simplicity is that things like render functions get displayed exactly where they appear in the code.
This is great for basic apps, since you don't have to separate backend from frontend (aka server from UI) logic.
However, this can lead to code that's harder to reason about when it grows in size and complexity.
For example, consider this snippet Express app -- can you visualize, at a glance, how the overall UI is structured?

<details open>
  <summary style="margin-bottom: -1em;">Hide code</summary>
```{.python}
with ui.layout_columns():
    with ui.card():
        @render.plot
        def pair_plot():
            df = load_penguins()
            if df is None:
                print("Dataframe is empty")
                return

            # Drop rows with missing values
            df = df.dropna()

            # Get list of features
            features = df.select_dtypes(include=[np.number]).columns.tolist()

            # Create a figure and axes with a subplot for each pair of features
            fig, axs = plt.subplots(len(features), len(features), figsize=(15, 15))

            # Create scatter plots for each pair of features
            for i in range(len(features)):
                for j in range(len(features)):
                    if i != j:
                        for species in df['species'].unique():
                            axs[i, j].scatter(df[df['species']==species][features[i]],
                                              df[df['species']==species][features[j]],
                                              label=species)
                        axs[i, j].set_xlabel(features[i])
                        axs[i, j].set_ylabel(features[j])
                    else:
                        axs[i, j].text(0.5, 0.5, features[i], ha='center', va='center')

            # Add a legend
            handles, labels = axs[0, 1].get_legend_handles_labels()
            fig.legend(handles, labels, loc='upper center')

            fig.tight_layout()
            return fig
        ui.input_select("species", "Species", ["Chinstrap", "Adelie", "Gentoo"])
```
</details>

The `render.plot` function above has a lot going on, and so it's easy to overlook that there's a `ui.input_select()` which appears just below the plot, inside the same card.
Also, with multiple levels of indentation, it's easy to mess up the identation; and as a result, have the input appear in the wrong place, or not work at all.

Express does offer a way to workaround this problem: the `ui.hold()` context manager, which allows you to define a `render` function in one place, then display it in another.
This, in a sense, is similar to what Shiny Core forces you to do: separate server from UI logic, and then connect them together with an `ui.output_*()` container element.
As a result, it's a lot more clear how the overall UI is structured:

```{.python}
with ui.hold():
    @render.plot
    def pair_plot():
        ... # code here


# Overall UI structure is now more clear
with ui.layout_columns():
    with ui.card():
        ui.output_plot("pair_plot")
        ui.input_select("species", "Species", ["Chinstrap", "Adelie", "Gentoo"])
```

::: callout-note
### Decoupling in Shiny Core

In the [next article](express-difference.qmd), we'll see how to actually define your UI and server logic in Shiny Core.
:::

::: callout-note
### Holding other express code

You can also use `ui.hold()` to hold other Express code, not just `render` functions.
For example:

```python
with ui.hold() as hello_card:
    with ui.card():
        "Hello world!"

hello_card
hello_card
```

In this way, it's related to the `@expressify` decorator, which allows you to reuse Express code in a parameterized way.
:::


## Functional programming {#functional}

Another reason why Express feels _expressive_ is that it promotes an imperative ([opposed to functional](https://en.wikipedia.org/wiki/Functional_programming#Comparison_to_imperative_programming)) programming style that is easier to get started with, but again, can make it difficult to manage complexity and reason about your app.
In particular, keeping track of UI state throughout the app can be difficult since imperative commands can change that state at any point in the code.
For example, consider this snippet of Express code -- understanding the state of the UI requires mentally parsing the code, and keeping track of the side-effects.

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 50
import shiny.express

for i in range(5):
    if i % 2 == 0:
        f"Even: {i} "
```

That said, you can certainly write functional code in Express, which at least limits the amount of side-effects to keep track of, and also provides a means for storing UI state in an inspectable object.

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 50
import shiny.express

x = [f"Even: {i} " for i in range(5) if i % 2 == 0]
x
```

::: callout-note
### Shiny Core avoids side-effects

In a sense, Shiny Core _forces_ you to avoid using imperative code to define your UI, since you're expected to define your UI as a single, tree-like, object.
:::

### Reusable express code

Another problem that arises from building UIs via side-effects is that it's not always clear how create reusable side-effects (i.e., avoid repeating yourself).
Express does provide a solution for this: wrap your Express code in a function decorated with `@expressify`.
Just make sure to call this function for it's side-effects, and not for its return value.

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 50
from shiny.express import expressify

@expressify
def evens(n = 5):
    for i in range(n):
        if i % 2 == 0:
            f"Even: {i} "

evens(3)
"--- "
evens(6)
```

::: callout-note
### Shiny Core embraces reusable functions

Since Shiny Core embraces functional programming, creating reusable code is as simple as defining a function.
:::


### Reactive express code {#reactive-displays}

In a basic Express app, essentially just render functions are reactive.
That is, other UI components like inputs, strings, etc. are static: they don't change once the app is rendered.
In order to make those otherwise static components reactive, you have to wrap them in a function decorated with `@render.express`.
This decorator is a bit of an exception to the rule compared to other `render` decorators since it's called for its side-effects, and not for its return value.

For example, suppose we want a checkbox to toggle whether to display even or odd numbers.
We can do this by wrapping the Express code in a function and decorating it with `@render.express`.
As a result, you can read reactive dependencies (e.g., `input.even()`), and function will be re-run whenever those dependencies change.

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 100

from shiny.express import input, render, ui

ui.input_switch("even", "Even", True)

@render.express
def numbers():
    remain = 0 if input.even() else 1
    label = "Even" if input.even() else "Odd"
    for i in range(5):
        if i % 2 == remain:
            f"{label}: {i} "
```


## Modules

Shiny Core allows you to break your app into [modules](#modules) to reuse both UI and server code.
Currently modules are not supported in Shiny Express.


## Lifecycle

For better perfomance, it's often useful to have some code run _once_ when the app initializes, not every time a new connection (i.e., session) is made.
Normal Express code is re-executed everytime a new connection is made, so it's not a good place to do expensive work that only needs to be done once.
Fortunately, if you move expensive code to a separate module, it will only be executed once (and objects can then be shared across sessions).

```{shinylive-python}
#| standalone: true
#| components: [editor, viewer]
#| layout: vertical
#| viewerHeight: 120

from shiny.express import render
import shared
# Runs once per session
@render.data_frame
def df():
    return shared.df

## file: shared.py
# Runs once per startup
import pandas as pd
from pathlib import Path
df = pd.read_csv(Path(__file__).parent / "data.csv")
## file: data.csv
col1,col2
1,2
3,4
```


::: callout-note
### Shiny Core lifecycle

In Shiny Core, code outside of the `server` function scope runs once per startup (not per user session).
See the code below for the equivalent Shiny Core app.

<details>
  <summary>Show code</summary>
```{.python}
from shiny import App, render, ui
import pandas as pd
from pathlib import Path

df = pd.read_csv(Path(__file__).parent / "data.csv") # Read in once

app_ui = ui.page_fixed(ui.output_data_frame("dat"))

def server(input, output, session):
    @render.data_frame
    def dat():
        # Returned to each session
        return df

app = App(app_ui, server)
```
</details>
:::

::: callout-tip
### Shared reactive objects

It's also possible to share reactive objects across sessions.
This can be potentially dangerous since one users activity could impact another's, but also quite useful in combination [`reactive.file_reader`](../api/reactive.file_reader.qmd) and [`reactive.poll`](../api/reactive.poll.qmd) to create a reactive data source that's only polled once, no matter how many users are connected.
:::


## Session object

Shiny apps have an object that represent a particular user's [session](../api/Session.html).
This object is useful for a variety of more advanced tasks like [sending messages to the client](../api/Session.html#shiny.Session.send_custom_message) and [serving up session-specific data](../api/Session.html#shiny.Session.dynamic_route).
In Express, it's possible to access the session object, but it's a bit trickier to use.
That's because, Express gets executed once before any session is created, then again once a session is established.[^execute-twice]
As a result, you have to check if the session object exists before using it.

[^execute-twice]: Another potential reason to prefer Shiny Core is that you have to worry about expensive UI code getting executed twice.

```{shinylive-python}
#| standalone: true
#| components: [edi#| tor, viewer]
#| layout: vertical
#| viewerHeight: 75
from shiny import reactive
from shiny.express import session, ui

@reactive.effect
async def _():
    if session:
        x = {"message": "Hello from Python!"}
        await session.send_custom_message("send_alert", x)

ui.tags.script(
    """
    Shiny.addCustomMessageHandler("send_alert", function(x) {
        document.body.innerHTML = x.message;
    });
    """
)
```

::: callout-note
### Shiny Core sessions

In Shiny Core, the session object is always fully defined in the `server` function.
:::


## Explicit UI containers

In [decoupling](#decoupling), we first saw how decoupling server from UI logic requires a `ui.output_*()` container element connect the two.
Power users will find that having explicit control over these containers gives them more control over those component styling (since [UI is HTML](ui-components.qmd), HTML/CSS can be used to customise the component containers).

Express has one other important place where an implicit UI container is used: the overall page layout.
This is often convenient, since Express can infer a sensible layout based on the top-level UI components, but it can also be limiting to not have explicit control over the page layout.
Express does offer a `ui.page_opts()` to add a title and other page options, but it's not as flexible working directly with an explicit page container.


## Conclusion

Shiny Express does a great job of simplifying the Shiny development process, but it does so by hiding some options which are useful for building and maintaining large apps.
As you grow as a Shiny developer and build larger more involved apps, you should consider using Shiny Core to take advantage of these features.
